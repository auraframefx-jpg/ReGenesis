package dev.aurakai.auraframefx.domains.aura.ui

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.net.Uri
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.documentfile.provider.DocumentFile
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.util.UUID
import dev.aurakai.auraframefx.domains.aura.lab.ImageTransformation // Corrected import
import dev.aurakai.auraframefx.domains.aura.lab.CustomizationPreferences
import android.graphics.Bitmap
import android.util.LruCache

object ImageResourceManager {

    // In-memory cache for transformed Bitmaps
    private val transformedImageCache = LruCache<String, Bitmap>(4 * 1024 * 1024) // 4MB cache

    /**
     * Generates a unique cache key for a transformed image.
     * @param uri The original image URI.
     * @param transformation The transformation parameters.
     * @return A unique String key.
     */
    fun generateCacheKey(uri: Uri, transformation: ImageTransformation): String {
        return "${uri.toString()}-${transformation.hashCode()}"
    }

    /**
     * Retrieves a transformed Bitmap from the cache.
     * @param key The cache key generated by generateCacheKey.
     * @return The cached Bitmap, or null if not found.
     */
    fun getTransformedImageFromCache(key: String): Bitmap? {
        return transformedImageCache.get(key)
    }

    /**
     * Stores a transformed Bitmap in the cache.
     * @param key The cache key generated by generateCacheKey.
     * @param bitmap The Bitmap to store.
     */
    fun putTransformedImageToCache(key: String, bitmap: Bitmap) {
        transformedImageCache.put(key, bitmap)
    }

    private const val TAG = "ImageResourceManager"
    private const val IMAGE_SUBDIRECTORY = "custom_images"

    /**
     * Copies an image from a given Uri to the app-specific internal storage and stores its transformation.
     * Generates a unique filename for the stored image.
     * @param context The application context.
     * @param sourceUri The Uri of the image to copy.
     * @param usageKey A key to track the usage of this image (e.g., "header_image", "nav_drawer_background").
     * @param transformation The ImageTransformation object to store with the image.
     * @return The Uri of the newly copied image in internal storage, or null if copy fails.
     */
    suspend fun copyImageToInternalStorage(
        context: Context,
        sourceUri: Uri,
        usageKey: String,
        transformation: ImageTransformation
    ): Uri? {
        return withContext(Dispatchers.IO) {
            if (!hasReadExternalStoragePermission(context)) {
                Log.e(TAG, "Permission denied: READ_EXTERNAL_STORAGE needed to copy image from $sourceUri.")
                return@withContext null
            }

            val appSpecificDir = File(context.filesDir, IMAGE_SUBDIRECTORY)
            if (!appSpecificDir.exists()) {
                appSpecificDir.mkdirs()
            }

            val uniqueFileName = "${UUID.randomUUID()}.jpg"
            val destinationFile = File(appSpecificDir, uniqueFileName)

            try {
                context.contentResolver.openInputStream(sourceUri)?.use {
                    inputStream ->
                    FileOutputStream(destinationFile).use {
                        outputStream ->
                        inputStream.copyTo(outputStream)
                    }
                }
                val internalUri = Uri.fromFile(destinationFile)
                Log.d(TAG, "Image copied to internal storage: $internalUri")

                CustomizationPreferences.saveImageWithTransformation(context, usageKey, internalUri, transformation)

                return@withContext internalUri
            } catch (e: IOException) {
                Log.e(TAG, "Failed to copy image from $sourceUri to internal storage: ${e.message}")
                return@withContext null
            } catch (e: SecurityException) {
                Log.e(TAG, "Security exception when accessing image $sourceUri: ${e.message}. Ensure permissions or URI access is correct.")
                return@withContext null
            }
        }
    }

    /**
     * Deletes an image from internal storage if it's no longer referenced in preferences.
     * @param context The application context.
     * @param imageUri The Uri of the image to potentially delete.
     */
    fun deleteImageIfOrphaned(context: Context, imageUri: Uri) {
        val filePath = imageUri.path ?: return
        val file = File(filePath)

        if (file.exists() && file.delete()) {
            Log.d(TAG, "Image file deleted from internal storage: $imageUri")
        } else {
            Log.w(TAG, "Failed to delete image file or file not found: $imageUri")
        }
    }

    /**
     * Cleans up all orphaned images not currently referenced in any customization preferences.
     */
    fun cleanupOrphanedImages(context: Context) {
        val appSpecificDir = File(context.filesDir, IMAGE_SUBDIRECTORY)
        if (!appSpecificDir.exists()) return

        val referencedUris = CustomizationPreferences.getAllReferencedImageUris(context)

        appSpecificDir.listFiles()?.forEach {
            file ->
            val fileUri = Uri.fromFile(file)
            if (fileUri !in referencedUris) {
                if (file.delete()) {
                    Log.d(TAG, "Cleaned up untracked image: $fileUri")
                } else {
                    Log.w(TAG, "Failed to delete untracked image: $fileUri")
                }
            }
        }
        Log.i(TAG, "Orphaned image cleanup complete.")
    }

    /**
     * Checks if the app has READ_EXTERNAL_STORAGE permission.
     * @param context The application context.
     * @return True if permission is granted, false otherwise.
     */
    fun hasReadExternalStoragePermission(context: Context): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.READ_EXTERNAL_STORAGE
        ) == PackageManager.PERMISSION_GRANTED
    }

    // Utility to get a content Uri for a file, for sharing if needed
    fun getFileContentUri(context: Context, file: File): Uri? {
        // val fileProviderAuthority = "${context.packageName}.fileprovider"
        return try {
            Uri.fromFile(file)
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, "Error getting content URI for file: ${e.message}")
            null
        }
    }

    /**
     * Helper function to convert a String to a Uri safely.
     */
    fun stringToUri(uriString: String?): Uri? {
        return uriString?.let { Uri.parse(it) }
    }

    /**
     * Removes an image usage entry from preferences and potentially deletes the image file.
     * @param context The application context.
     * @param usageKey The key for the image to remove.
     */
    fun removeImageUsage(context: Context, usageKey: String) {
        val (uriToRemove, _) = CustomizationPreferences.getImageWithTransformation(context, usageKey)
        CustomizationPreferences.clearImageWithTransformation(context, usageKey)
        uriToRemove?.let { deleteImageIfOrphaned(context, it) }
        Log.d(TAG, "Removed image usage for $usageKey and cleared preferences.")
    }
}
